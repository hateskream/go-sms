// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: spaces.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCardNumber = `-- name: AddCardNumber :one
INSERT INTO cars (number)
VALUES ($1::VARCHAR) RETURNING id
`

func (q *Queries) AddCardNumber(ctx context.Context, number string) (int32, error) {
	row := q.db.QueryRow(ctx, addCardNumber, number)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addFeature = `-- name: AddFeature :one
INSERT INTO features (name)
VALUES ($1) RETURNING id
`

func (q *Queries) AddFeature(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, addFeature, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addPricingGroup = `-- name: AddPricingGroup :one
INSERT INTO pricing_groups (name)
VALUES ($1) RETURNING id
`

func (q *Queries) AddPricingGroup(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, addPricingGroup, name)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addReservation = `-- name: AddReservation :one
INSERT INTO space_reservations (time_from, time_to, car_id, reservation_fee, space_id, status_id)
VALUES ($1,$2,$3,$4,$5,$6) RETURNING id
`

type AddReservationParams struct {
	TimeFrom       pgtype.Timestamp `json:"time_from"`
	TimeTo         pgtype.Timestamp `json:"time_to"`
	CarID          pgtype.Int4      `json:"car_id"`
	ReservationFee float32          `json:"reservation_fee"`
	SpaceID        pgtype.Int4      `json:"space_id"`
	StatusID       pgtype.Int4      `json:"status_id"`
}

func (q *Queries) AddReservation(ctx context.Context, arg AddReservationParams) (int32, error) {
	row := q.db.QueryRow(ctx, addReservation,
		arg.TimeFrom,
		arg.TimeTo,
		arg.CarID,
		arg.ReservationFee,
		arg.SpaceID,
		arg.StatusID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const addSpace = `-- name: AddSpace :one
INSERT INTO spaces (name, physical_id, group_id, status_id)
VALUES ($1,$2,$3,$4)
RETURNING  id
`

type AddSpaceParams struct {
	Name       string      `json:"name"`
	PhysicalID pgtype.Int4 `json:"physical_id"`
	GroupID    pgtype.Int4 `json:"group_id"`
	StatusID   pgtype.Int4 `json:"status_id"`
}

func (q *Queries) AddSpace(ctx context.Context, arg AddSpaceParams) (int32, error) {
	row := q.db.QueryRow(ctx, addSpace,
		arg.Name,
		arg.PhysicalID,
		arg.GroupID,
		arg.StatusID,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const assignSpaceFeature = `-- name: AssignSpaceFeature :one
INSERT INTO space_features (space_id, feature_id, is_required) 
VALUES ($1, $2, $3) RETURNING id
`

type AssignSpaceFeatureParams struct {
	SpaceID    pgtype.Int4 `json:"space_id"`
	FeatureID  pgtype.Int4 `json:"feature_id"`
	IsRequired bool        `json:"is_required"`
}

func (q *Queries) AssignSpaceFeature(ctx context.Context, arg AssignSpaceFeatureParams) (int32, error) {
	row := q.db.QueryRow(ctx, assignSpaceFeature, arg.SpaceID, arg.FeatureID, arg.IsRequired)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const cleanTimePricingPolicy = `-- name: CleanTimePricingPolicy :exec
DELETE FROM time_pricing_policy
WHERE group_id = $1
`

func (q *Queries) CleanTimePricingPolicy(ctx context.Context, groupID int32) error {
	_, err := q.db.Exec(ctx, cleanTimePricingPolicy, groupID)
	return err
}

const deleteFeature = `-- name: DeleteFeature :one
DELETE FROM features
WHERE id = $1 RETURNING id
`

func (q *Queries) DeleteFeature(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteFeature, id)
	err := row.Scan(&id)
	return id, err
}

const deletePricingGroup = `-- name: DeletePricingGroup :one
DELETE FROM pricing_groups
WHERE id = $1 RETURNING id
`

func (q *Queries) DeletePricingGroup(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deletePricingGroup, id)
	err := row.Scan(&id)
	return id, err
}

const deleteSpace = `-- name: DeleteSpace :one
DELETE FROM spaces
WHERE id = $1 RETURNING id
`

func (q *Queries) DeleteSpace(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRow(ctx, deleteSpace, id)
	err := row.Scan(&id)
	return id, err
}

const deleteSpaceFeatures = `-- name: DeleteSpaceFeatures :exec
DELETE FROM space_features
WHERE space_id = $1
`

func (q *Queries) DeleteSpaceFeatures(ctx context.Context, spaceID pgtype.Int4) error {
	_, err := q.db.Exec(ctx, deleteSpaceFeatures, spaceID)
	return err
}

const generatTimePricingPolicy = `-- name: GeneratTimePricingPolicy :exec
INSERT INTO time_pricing_policy (rate, hour, day_of_week, group_id)
SELECT $2, hour, day_of_week, $1
FROM generate_series(1, 8) AS day_of_week
CROSS JOIN generate_series(1, 24) AS hour
`

type GeneratTimePricingPolicyParams struct {
	GroupID int32   `json:"group_id"`
	Rate    float32 `json:"rate"`
}

func (q *Queries) GeneratTimePricingPolicy(ctx context.Context, arg GeneratTimePricingPolicyParams) error {
	_, err := q.db.Exec(ctx, generatTimePricingPolicy, arg.GroupID, arg.Rate)
	return err
}

const getActiveReservations = `-- name: GetActiveReservations :many
SELECT id, time_from, time_to, car_id, status_id, space_id
FROM space_reservations as r
WHERE status_id = 1 OR status_id = 2
`

type GetActiveReservationsRow struct {
	ID       int32            `json:"id"`
	TimeFrom pgtype.Timestamp `json:"time_from"`
	TimeTo   pgtype.Timestamp `json:"time_to"`
	CarID    pgtype.Int4      `json:"car_id"`
	StatusID pgtype.Int4      `json:"status_id"`
	SpaceID  pgtype.Int4      `json:"space_id"`
}

func (q *Queries) GetActiveReservations(ctx context.Context) ([]GetActiveReservationsRow, error) {
	rows, err := q.db.Query(ctx, getActiveReservations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveReservationsRow
	for rows.Next() {
		var i GetActiveReservationsRow
		if err := rows.Scan(
			&i.ID,
			&i.TimeFrom,
			&i.TimeTo,
			&i.CarID,
			&i.StatusID,
			&i.SpaceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCardByNumber = `-- name: GetCardByNumber :one
SELECT cars.id
FROM cars
WHERE cars.number = $1::VARCHAR
`

func (q *Queries) GetCardByNumber(ctx context.Context, number string) (int32, error) {
	row := q.db.QueryRow(ctx, getCardByNumber, number)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getFeatures = `-- name: GetFeatures :many
SELECT id, name
FROM features
ORDER BY id
`

func (q *Queries) GetFeatures(ctx context.Context) ([]Feature, error) {
	rows, err := q.db.Query(ctx, getFeatures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Feature
	for rows.Next() {
		var i Feature
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPricingPolicy = `-- name: GetPricingPolicy :many
SELECT pg.name, tpp.id, tpp.rate, tpp.hour, tpp.day_of_week, tpp.group_id
FROM time_pricing_policy as tpp
JOIN pricing_groups as pg ON pg.id = tpp.group_id
WHERE pg.id = $1
`

type GetPricingPolicyRow struct {
	Name      string  `json:"name"`
	ID        int32   `json:"id"`
	Rate      float32 `json:"rate"`
	Hour      int16   `json:"hour"`
	DayOfWeek int16   `json:"day_of_week"`
	GroupID   int32   `json:"group_id"`
}

func (q *Queries) GetPricingPolicy(ctx context.Context, id int32) ([]GetPricingPolicyRow, error) {
	rows, err := q.db.Query(ctx, getPricingPolicy, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPricingPolicyRow
	for rows.Next() {
		var i GetPricingPolicyRow
		if err := rows.Scan(
			&i.Name,
			&i.ID,
			&i.Rate,
			&i.Hour,
			&i.DayOfWeek,
			&i.GroupID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservationStatuses = `-- name: GetReservationStatuses :many
SELECT id, name
FROM reservation_statuses
`

func (q *Queries) GetReservationStatuses(ctx context.Context) ([]ReservationStatus, error) {
	rows, err := q.db.Query(ctx, getReservationStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ReservationStatus
	for rows.Next() {
		var i ReservationStatus
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservationsHistory = `-- name: GetReservationsHistory :many
SELECT space_reservations.id, time_from, time_to, car_id, reservation_fee, status_id, space_id, parking_time_from, parking_time_to, parking_fee, parking_fee_breakdown, tmp.id FROM space_reservations
    INNER JOIN (      
      SELECT id FROM space_reservations WHERE space_reservations.time_from >= $3 AND space_reservations.time_from <= $4
      ORDER BY time_from, id LIMIT $1 OFFSET $2      
    ) AS tmp USING (id) 
ORDER BY
  time_from
`

type GetReservationsHistoryParams struct {
	Limit      int32            `json:"limit"`
	Offset     int32            `json:"offset"`
	TimeFrom   pgtype.Timestamp `json:"time_from"`
	TimeFrom_2 pgtype.Timestamp `json:"time_from_2"`
}

type GetReservationsHistoryRow struct {
	ID                  int32            `json:"id"`
	TimeFrom            pgtype.Timestamp `json:"time_from"`
	TimeTo              pgtype.Timestamp `json:"time_to"`
	CarID               pgtype.Int4      `json:"car_id"`
	ReservationFee      float32          `json:"reservation_fee"`
	StatusID            pgtype.Int4      `json:"status_id"`
	SpaceID             pgtype.Int4      `json:"space_id"`
	ParkingTimeFrom     pgtype.Timestamp `json:"parking_time_from"`
	ParkingTimeTo       pgtype.Timestamp `json:"parking_time_to"`
	ParkingFee          float32          `json:"parking_fee"`
	ParkingFeeBreakdown float32          `json:"parking_fee_breakdown"`
	ID_2                int32            `json:"id_2"`
}

func (q *Queries) GetReservationsHistory(ctx context.Context, arg GetReservationsHistoryParams) ([]GetReservationsHistoryRow, error) {
	rows, err := q.db.Query(ctx, getReservationsHistory,
		arg.Limit,
		arg.Offset,
		arg.TimeFrom,
		arg.TimeFrom_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReservationsHistoryRow
	for rows.Next() {
		var i GetReservationsHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.TimeFrom,
			&i.TimeTo,
			&i.CarID,
			&i.ReservationFee,
			&i.StatusID,
			&i.SpaceID,
			&i.ParkingTimeFrom,
			&i.ParkingTimeTo,
			&i.ParkingFee,
			&i.ParkingFeeBreakdown,
			&i.ID_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReservationsHistoryCount = `-- name: GetReservationsHistoryCount :one
SELECT COUNT(*) from space_reservations
WHERE space_reservations.time_from > $1 AND space_reservations.time_from < $2
`

type GetReservationsHistoryCountParams struct {
	TimeFrom   pgtype.Timestamp `json:"time_from"`
	TimeFrom_2 pgtype.Timestamp `json:"time_from_2"`
}

func (q *Queries) GetReservationsHistoryCount(ctx context.Context, arg GetReservationsHistoryCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getReservationsHistoryCount, arg.TimeFrom, arg.TimeFrom_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getSpacePrices = `-- name: GetSpacePrices :many
SELECT
    s.id,    
    tpp.rate
FROM
    spaces AS s
JOIN
    pricing_groups pg ON s.group_id = pg.id
JOIN
    time_pricing_policy tpp ON tpp.group_id = pg.id   
WHERE
  tpp.day_of_week = $1 AnD tpp.hour = $2     
GROUP BY s.id, tpp.rate
`

type GetSpacePricesParams struct {
	DayOfWeek int16 `json:"day_of_week"`
	Hour      int16 `json:"hour"`
}

type GetSpacePricesRow struct {
	ID   int32   `json:"id"`
	Rate float32 `json:"rate"`
}

func (q *Queries) GetSpacePrices(ctx context.Context, arg GetSpacePricesParams) ([]GetSpacePricesRow, error) {
	rows, err := q.db.Query(ctx, getSpacePrices, arg.DayOfWeek, arg.Hour)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpacePricesRow
	for rows.Next() {
		var i GetSpacePricesRow
		if err := rows.Scan(&i.ID, &i.Rate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpaceStatuses = `-- name: GetSpaceStatuses :many
SELECT id, name
FROM space_statuses
`

func (q *Queries) GetSpaceStatuses(ctx context.Context) ([]SpaceStatus, error) {
	rows, err := q.db.Query(ctx, getSpaceStatuses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpaceStatus
	for rows.Next() {
		var i SpaceStatus
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpaces = `-- name: GetSpaces :many
SELECT
    s.id,
    s.name,
    space_statuses.name AS status,        
    COALESCE(CAST(string_agg(CASE WHEN sf.is_required THEN f.name END, ',') AS VARCHAR), '') AS required_features,
    COALESCE(CAST(string_agg(f.name, ',') AS VARCHAR), '') AS features
FROM
    spaces AS s
JOIN
    space_features sf ON s.id = sf.space_id                
JOIN
    features f ON sf.feature_id = f.id    
JOIN
    (
        SELECT DISTINCT ON (s.id) s.id, space_statuses.name
        FROM spaces AS s
        JOIN space_statuses ON s.status_id = space_statuses.id
        ORDER BY s.id
    ) AS space_statuses ON s.id = space_statuses.id  
GROUP BY s.id, space_statuses.name
`

type GetSpacesRow struct {
	ID               int32       `json:"id"`
	Name             string      `json:"name"`
	Status           string      `json:"status"`
	RequiredFeatures interface{} `json:"required_features"`
	Features         interface{} `json:"features"`
}

func (q *Queries) GetSpaces(ctx context.Context) ([]GetSpacesRow, error) {
	rows, err := q.db.Query(ctx, getSpaces)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSpacesRow
	for rows.Next() {
		var i GetSpacesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.RequiredFeatures,
			&i.Features,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFeature = `-- name: UpdateFeature :exec
UPDATE features
  set name = $2  
WHERE id = $1
`

type UpdateFeatureParams struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpdateFeature(ctx context.Context, arg UpdateFeatureParams) error {
	_, err := q.db.Exec(ctx, updateFeature, arg.ID, arg.Name)
	return err
}

const updatePricingGroups = `-- name: UpdatePricingGroups :exec
UPDATE pricing_groups
  set name = $2
  WHERE id = $1
`

type UpdatePricingGroupsParams struct {
	ID   int32  `json:"id"`
	Name string `json:"name"`
}

func (q *Queries) UpdatePricingGroups(ctx context.Context, arg UpdatePricingGroupsParams) error {
	_, err := q.db.Exec(ctx, updatePricingGroups, arg.ID, arg.Name)
	return err
}

const updatePricingPolicy = `-- name: UpdatePricingPolicy :exec
UPDATE time_pricing_policy
  set rate = $2
  WHERE ID = $1
`

type UpdatePricingPolicyParams struct {
	ID   int32   `json:"id"`
	Rate float32 `json:"rate"`
}

func (q *Queries) UpdatePricingPolicy(ctx context.Context, arg UpdatePricingPolicyParams) error {
	_, err := q.db.Exec(ctx, updatePricingPolicy, arg.ID, arg.Rate)
	return err
}

const updateReservationParkingData = `-- name: UpdateReservationParkingData :exec
UPDATE space_reservations
  set parking_time_from = $2, parking_time_to = $3, parking_fee = $4, parking_fee_breakdown = $5
WHERE space_reservations.id = $1
`

type UpdateReservationParkingDataParams struct {
	ID                  int32            `json:"id"`
	ParkingTimeFrom     pgtype.Timestamp `json:"parking_time_from"`
	ParkingTimeTo       pgtype.Timestamp `json:"parking_time_to"`
	ParkingFee          float32          `json:"parking_fee"`
	ParkingFeeBreakdown float32          `json:"parking_fee_breakdown"`
}

func (q *Queries) UpdateReservationParkingData(ctx context.Context, arg UpdateReservationParkingDataParams) error {
	_, err := q.db.Exec(ctx, updateReservationParkingData,
		arg.ID,
		arg.ParkingTimeFrom,
		arg.ParkingTimeTo,
		arg.ParkingFee,
		arg.ParkingFeeBreakdown,
	)
	return err
}

const updateReservationStatus = `-- name: UpdateReservationStatus :exec
UPDATE space_reservations
  set status_id = $2
WHERE space_reservations.id = $1
`

type UpdateReservationStatusParams struct {
	ID       int32       `json:"id"`
	StatusID pgtype.Int4 `json:"status_id"`
}

func (q *Queries) UpdateReservationStatus(ctx context.Context, arg UpdateReservationStatusParams) error {
	_, err := q.db.Exec(ctx, updateReservationStatus, arg.ID, arg.StatusID)
	return err
}

const updateSpace = `-- name: UpdateSpace :exec
UPDATE spaces
  set name = $2,
  physical_id = $3,
  group_id = $4,
  status_id = $5
WHERE id = $1
`

type UpdateSpaceParams struct {
	ID         int32       `json:"id"`
	Name       string      `json:"name"`
	PhysicalID pgtype.Int4 `json:"physical_id"`
	GroupID    pgtype.Int4 `json:"group_id"`
	StatusID   pgtype.Int4 `json:"status_id"`
}

func (q *Queries) UpdateSpace(ctx context.Context, arg UpdateSpaceParams) error {
	_, err := q.db.Exec(ctx, updateSpace,
		arg.ID,
		arg.Name,
		arg.PhysicalID,
		arg.GroupID,
		arg.StatusID,
	)
	return err
}

const updateSpaceStatus = `-- name: UpdateSpaceStatus :one
UPDATE spaces
  set status_id = $3
WHERE spaces.id = $1 AND spaces.status_id = $2
RETURNING id
`

type UpdateSpaceStatusParams struct {
	ID         int32       `json:"id"`
	StatusID   pgtype.Int4 `json:"status_id"`
	StatusID_2 pgtype.Int4 `json:"status_id_2"`
}

func (q *Queries) UpdateSpaceStatus(ctx context.Context, arg UpdateSpaceStatusParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateSpaceStatus, arg.ID, arg.StatusID, arg.StatusID_2)
	var id int32
	err := row.Scan(&id)
	return id, err
}
